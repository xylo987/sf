--冒泡排序的算法原理
--
--假设用[]作为元素的容器，数字作为元素的表达；又假设用1根火柴表示数字1，
--2根火柴表示数字2，3根火柴表示数字3，并且我们认为，根数越多的火柴所代表
--的数字就越大，根数相同的火柴所代表的数字为相同，根数越少的火柴所代表的
--数字就越小，我们用`<`表示小于，`>`表示大于，`=`表示等于，`>=`表示大于
--等于，`<=`表示小于等于，则可以得出4 > 2，1 = 1 ，2 < 3。
--
--所以，我们可以得到，为了表达对拥有可比较的元素的容器的排序，我们的容器
--的元素必须满足条件：
--  1. 容器中的元素相互之间是可以进行比较的
--  2. 容器中必须要有为个数大于等于2的元素才能进行比较
--
--定义:
--  设列表L长度=len, 1 <= n <= len，L[n]为列表的第n个元素, 临时空间=tmp
--  循环计数器=count
--
--  当L = []时，L = [] 
--  当L = [x]时，L = [x]
--  当L = [x1,..,xn], n > 1 且 n为正整数，则
--  count = 0
--  while count < len 
--      n = 1
--      while n < len - count
--          if L[n] > L[n+1]
--              tmp = L[n]
--              L[n] = L[n+1]
--              L[n+1] = L[n]
--          n += 1
--      count += 1
--  此时L = [x, x <- 从小到大的排序元素的L]
--  ---------------------------
--      L     | 比较/交换次数 |
--  [4,3,2,1] | 3             |
--  [3,2,1,4] | 2             |
--  [2,1,3,4] | 1             |
--  [1,2,3,4] | 0             |
--  ---------------------------
--  可以看出，算法核心的步骤就是循环，比较，交换
--
--  比较的总共执行次数为
--  [0, len * (len - count), count <- [0, len)]
--
--  交换的总共执行次数为
--  [0, len * (len - count), count <- [0, len)]
--
--  这就是冒泡排序

-- 用函数式编程的思维来写就是：

-- 比较
bj :: (Ord x) => x -> x -> Bool
bj x y
    | x > y = True
    | otherwise = False

-- 交换
swap :: (Ord x) => [x] -> [x]
swap [] = []
swap [x] = [x]
swap (x1:x2:xs)
    | r == True = x2:swap (x1:xs)
    | otherwise = x1:swap (x2:xs)
    where r = (bj x1 x2)

-- 循环
loop :: Ord x => [x] -> [x]
loop xs
    | sxs == xs = xs
    | otherwise = loop (swap sxs)
    where sxs = (swap xs)

-- 优化
-- 在使用++运算符处理长字符串时要格外小心(对长List也是同样)，
-- Haskell会遍历整个的List(++符号左边的那个)。在处理较短的字
-- 符串时问题还不大，但要是在一个5000万长度的List上追加元素，
-- 那可得执行好一会儿了。所以说，用:运算符往一个List前端插入
-- 元素会是更好的选择，所以这里也只能算人脑的优化，程序就不是
loop' :: Ord x => [x] -> [x]
loop' [x] = [x]
loop' xs = (loop' le ++ [re])
    where 
        sxs = (swap xs)
        le = init sxs
        re = last sxs

-- 主函数
main = do
    -- ghc --make -O mpsort.hs
    print (loop' (reverse [1..1000]))
